#!/usr/bin/env python3

import logging
from typing import List, Dict, Any
from sqlalchemy.orm import Session
from pcb_part_finder.db.models import Project, BomItem
from .data_loader import load_project_data_from_db
from .output_writer import save_bom_results_to_db
from . import llm_handler
from . import mouser_api
from .llm_handler import LlmApiError
from .mouser_api import MouserApiError

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def process_project_from_db(project_id: str, db: Session) -> bool:
    """
    Process a project using data from the database.
    
    Args:
        project_id: The ID of the project to process
        db: Database session to use for queries and updates
        
    Returns:
        bool: True if processing was successful, False otherwise
    """
    try:
        logger.info(f"Starting processing for project {project_id}")
        
        # Load project data and BOM items
        project, bom_items = load_project_data_from_db(project_id, db)
        
        if not project:
            logger.error(f"Could not load project {project_id} from database")
            return False
            
        logger.info(f"Loaded project {project_id} with {len(bom_items)} BOM items")
        
        # Initialize lists for results and selected parts context
        bom_items_with_matches = []
        selected_part_details = []

        # Process BOM items with LLM and Mouser API
        for bom_item in bom_items:
            # Step 2: Generate Search Terms
            part_info = {
                'Description': bom_item.description or '',
                'Possible MPN': bom_item.notes or '',
                'Package': bom_item.package or '',
                'Notes/Source': bom_item.notes or ''
            }
            search_terms = []
            status = 'pending' # Initial status

            try:
                search_prompt = llm_handler.format_search_term_prompt(part_info)
                llm_response_terms = llm_handler.get_llm_response(search_prompt)
                search_terms = llm_handler.parse_search_terms(llm_response_terms)

                if not search_terms:
                    logger.warning(f"No search terms generated by LLM for item {bom_item.bom_item_id}")
                    status = 'search_term_failed'
            except LlmApiError as e:
                logger.error(f"LLM error generating search terms for item {bom_item.bom_item_id}: {e}")
                status = 'search_term_failed'

            # Step 3: Perform Mouser Keyword Search
            mouser_results = []
            unique_mouser_part_numbers = set()

            if status == 'pending' and search_terms:
                for term in search_terms:
                    try:
                        results = mouser_api.search_mouser_by_keyword(term)
                        for part in results:
                            mouser_part_number = part.get('MouserPartNumber')
                            if mouser_part_number and mouser_part_number not in unique_mouser_part_numbers:
                                unique_mouser_part_numbers.add(mouser_part_number)
                                mouser_results.append(part)
                    except MouserApiError as e:
                        logger.error(f"Mouser API keyword search error for item {bom_item.bom_item_id}, term '{term}': {e}")
                        # Continue to next term even if one fails
                
                if not mouser_results:
                    logger.warning(f"No unique Mouser results found for any search term for item {bom_item.bom_item_id}")
                    status = 'no_keyword_results'

            # Step 4: Evaluate Search Results with LLM
            chosen_mpn = None
            if status == 'pending' and mouser_results:
                try:
                    eval_prompt = llm_handler.format_evaluation_prompt(
                        part_info,
                        project.description, # Changed from project_notes to description
                        selected_part_details, # Use previously selected parts for context
                        mouser_results
                    )
                    llm_response_eval = llm_handler.get_llm_response(eval_prompt)
                    chosen_mpn = llm_handler.extract_mpn_from_eval(llm_response_eval)

                    if not chosen_mpn:
                        logger.warning(f"LLM did not select an MPN for item {bom_item.bom_item_id}")
                        status = 'evaluation_failed'
                except LlmApiError as e:
                    logger.error(f"LLM error evaluating search results for item {bom_item.bom_item_id}: {e}")
                    status = 'evaluation_failed'

            # Step 5: Get Final Part Details from Mouser by MPN
            final_part_details = None
            if status == 'pending' and chosen_mpn:
                try:
                    final_part_details = mouser_api.search_mouser_by_mpn(chosen_mpn)
                    if final_part_details:
                        status = 'matched' # Successfully found details
                    else:
                        logger.warning(f"Mouser MPN search returned no details for MPN '{chosen_mpn}' (item {bom_item.bom_item_id})")
                        status = 'mpn_lookup_failed'
                except MouserApiError as e:
                    logger.error(f"Mouser API MPN search error for item {bom_item.bom_item_id}, MPN '{chosen_mpn}': {e}")
                    status = 'mpn_lookup_failed'

            # Step 6: Format and Store Result
            match_data = {}
            
            if status == 'matched' and final_part_details:
                # Map fields from Mouser MPN search result to expected output keys
                match_data = {
                    'mouser_part_number': final_part_details.get('Mouser Part Number'),
                    'manufacturer_name': final_part_details.get('Manufacturer Name'),
                    'description': final_part_details.get('Mouser Description'), # Using Mouser Description
                    'datasheet_url': final_part_details.get('Datasheet URL'),
                    'price': final_part_details.get('Price'),
                    'availability': final_part_details.get('Availability'),
                    'match_status': status, # Use match_status key
                    'possible_mpn': final_part_details.get('Manufacturer Part Number') # Also store the MPN found
                }
                # Add details of the selected part for context in future LLM evaluations
                selected_part_details.append({
                    'Description': part_info.get('Description', ''),
                    'Manufacturer Part Number': final_part_details.get('Manufacturer Part Number')
                })
            else: # Handle all failure statuses and default error case
                # Ensure all expected keys exist, even if None
                match_data = {
                    'mouser_part_number': None,
                    'manufacturer_name': None,
                    'description': None,
                    'datasheet_url': None,
                    'price': None,
                    'availability': None,
                    'match_status': status if status != 'pending' else 'error', # Ensure status is set
                    'possible_mpn': None # Default possible_mpn
                }
                if status == 'mpn_lookup_failed':
                    # Include the MPN that failed if available
                    match_data['possible_mpn'] = chosen_mpn or part_info.get('Possible MPN', '')
                elif status == 'pending': # Should not happen, but handle defensively
                     logger.error(f"Item {bom_item.bom_item_id} reached end with unexpected 'pending' status.")
                     match_data['match_status'] = 'error'

            # Create the final data structure for this BOM item
            item_data = {
                'bom_item_id': bom_item.bom_item_id,
                'quantity': bom_item.quantity,
                'description': bom_item.description, # Original description
                'matches': [match_data]  # Expects a list of matches
            }
            
            bom_items_with_matches.append(item_data)

        # Save results to database
        success = save_bom_results_to_db(project_id, bom_items_with_matches, db)
        if not success:
            logger.error(f"Failed to save results for project {project_id}")
            return False
            
        logger.info(f"Successfully processed project {project_id}")
        return True
        
    except Exception as e:
        logger.error(f"Error processing project {project_id}: {str(e)}")
        return False 